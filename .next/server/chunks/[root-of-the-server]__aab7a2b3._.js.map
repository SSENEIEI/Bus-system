{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":["file:///Users/sonjutha/Downloads/Bus-system/src/app/api/route-pdfs/list/route.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { list } from \"@vercel/blob\";\n\nexport async function GET() {\n  try {\n    const isProd = process.env.VERCEL === '1' || process.env.NODE_ENV === 'production';\n    const map = {};\n    let lastUpdated = null;\n\n    if (isProd) {\n      // List blobs from Vercel Blob storage\n      try {\n        const resp = await list({ prefix: 'route-pdfs/' });\n        const blobs = resp?.blobs || resp?.items || [];\n        for (const b of blobs) {\n          const pathname = b.pathname || b.key || b.name || b.pathname;\n          if (!pathname || !pathname.endsWith('.pdf')) continue;\n          const filename = pathname.split('/').pop();\n          const key = filename.replace(/\\.pdf$/i, '');\n          map[key] = b.url || `https://blob.vercel-storage.com/${pathname}`;\n          const uploadedAt = b.uploadedAt ? new Date(b.uploadedAt).getTime() : (b.lastModified ? new Date(b.lastModified).getTime() : null);\n          if (uploadedAt && (!lastUpdated || uploadedAt > lastUpdated)) lastUpdated = uploadedAt;\n        }\n      } catch (e) {\n        // If listing fails, return empty map\n      }\n    } else {\n      // Local dev: read from public/route-pdfs\n      const dir = path.join(process.cwd(), 'public', 'route-pdfs');\n      try {\n        const files = await fs.readdir(dir);\n        for (const f of files) {\n          if (!f.toLowerCase().endsWith('.pdf')) continue;\n          const key = f.replace(/\\.pdf$/i, '');\n          map[key] = `/route-pdfs/${f}`;\n          try {\n            const st = await fs.stat(path.join(dir, f));\n            const m = st.mtimeMs || st.mtime?.getTime?.() || null;\n            if (m && (!lastUpdated || m > lastUpdated)) lastUpdated = m;\n          } catch {}\n        }\n      } catch {\n        // directory may not exist yet\n      }\n    }\n\n    return NextResponse.json({ map, lastUpdated });\n  } catch (err) {\n    return NextResponse.json({ error: 'failed to list' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,QAAQ,GAAG,CAAC,MAAM,KAAK,OAAO,oDAAyB;QACtE,MAAM,MAAM,CAAC;QACb,IAAI,cAAc;QAElB,IAAI,QAAQ;YACV,sCAAsC;YACtC,IAAI;gBACF,MAAM,OAAO,MAAM,IAAA,2KAAI,EAAC;oBAAE,QAAQ;gBAAc;gBAChD,MAAM,QAAQ,MAAM,SAAS,MAAM,SAAS,EAAE;gBAC9C,KAAK,MAAM,KAAK,MAAO;oBACrB,MAAM,WAAW,EAAE,QAAQ,IAAI,EAAE,GAAG,IAAI,EAAE,IAAI,IAAI,EAAE,QAAQ;oBAC5D,IAAI,CAAC,YAAY,CAAC,SAAS,QAAQ,CAAC,SAAS;oBAC7C,MAAM,WAAW,SAAS,KAAK,CAAC,KAAK,GAAG;oBACxC,MAAM,MAAM,SAAS,OAAO,CAAC,WAAW;oBACxC,GAAG,CAAC,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,gCAAgC,EAAE,UAAU;oBACjE,MAAM,aAAa,EAAE,UAAU,GAAG,IAAI,KAAK,EAAE,UAAU,EAAE,OAAO,KAAM,EAAE,YAAY,GAAG,IAAI,KAAK,EAAE,YAAY,EAAE,OAAO,KAAK;oBAC5H,IAAI,cAAc,CAAC,CAAC,eAAe,aAAa,WAAW,GAAG,cAAc;gBAC9E;YACF,EAAE,OAAO,GAAG;YACV,qCAAqC;YACvC;QACF,OAAO;YACL,yCAAyC;YACzC,MAAM,MAAM,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU;YAC/C,IAAI;gBACF,MAAM,QAAQ,MAAM,yGAAE,CAAC,OAAO,CAAC;gBAC/B,KAAK,MAAM,KAAK,MAAO;oBACrB,IAAI,CAAC,EAAE,WAAW,GAAG,QAAQ,CAAC,SAAS;oBACvC,MAAM,MAAM,EAAE,OAAO,CAAC,WAAW;oBACjC,GAAG,CAAC,IAAI,GAAG,CAAC,YAAY,EAAE,GAAG;oBAC7B,IAAI;wBACF,MAAM,KAAK,MAAM,yGAAE,CAAC,IAAI,CAAC,4GAAI,CAAC,IAAI,CAAC,KAAK;wBACxC,MAAM,IAAI,GAAG,OAAO,IAAI,GAAG,KAAK,EAAE,eAAe;wBACjD,IAAI,KAAK,CAAC,CAAC,eAAe,IAAI,WAAW,GAAG,cAAc;oBAC5D,EAAE,OAAM,CAAC;gBACX;YACF,EAAE,OAAM;YACN,8BAA8B;YAChC;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;YAAK;QAAY;IAC9C,EAAE,OAAO,KAAK;QACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;AACF","debugId":null}}]
}